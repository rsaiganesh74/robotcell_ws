#!/usr/bin/env python3

import sys
import requests

from PyQt5 import QtWidgets, QtCore
from PyQt5.QtCore import * 
from PyQt5.QtGui import QFont

import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor
from std_msgs.msg import Bool, Int8

# Your UI file generated by pyuic5 (assumed to be imported as Ui_MainWindow)
from hmi.config.hmi_ui import Ui_MainWindow

# Define a ROS2 subscriber node (similar to before)
class RosSubscriberNode(Node):
    def __init__(self):
        super().__init__('ros_subscriber_node')
        self.door_state = True
        self.estop_state = False
        self.stack_light_state = 0
        
        self.create_subscription(Bool, 'door_status', self.door_callback, 10)
        self.create_subscription(Bool, 'estop_status', self.estop_callback, 10)
        self.create_subscription(Int8, 'stack_light_status', self.stack_light_callback, 10)

    def door_callback(self, msg):
        self.door_state = msg.data

    def estop_callback(self, msg):
        self.estop_state = msg.data

    def stack_light_callback(self, msg):
        self.stack_light_state = msg.data

# Create a QRunnable for running ROS spin
class RosSpinRunnable(QRunnable):
    def __init__(self, node, executor,*args, **kwargs):
        super().__init__()
        self.node = node
        self.executor = executor

    @pyqtSlot()
    def run(self):
        self.executor.spin()

class WorkerSignals(QtCore.QObject):
    result = pyqtSignal(dict)  # Emits the JSON result from the GET request
    error = pyqtSignal(str)    # Emits an error message as string

class GetStatusWorker(QRunnable):
    def __init__(self, url):
        super(GetStatusWorker, self).__init__()
        self.url = url
        self.signals = WorkerSignals()

    @pyqtSlot()
    def run(self):
        try:
            response = requests.get(self.url, timeout=5)
            response.raise_for_status()
            data = response.json()
        except Exception as e:
            self.signals.error.emit(str(e))
        else:
            self.signals.result.emit(data)

# Your main window that updates indicators based on ROS node state
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, ros_node):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.ros_node = ros_node

        self._translate = QtCore.QCoreApplication.translate
        
        # Set initial colors
        self.ui.door_color.setStyleSheet("background-color: green;")
        self.ui.estop_color.setStyleSheet("background-color: green;")
        self.ui.stack_light_color.setStyleSheet("background-color: green;")

        self.ui.door_color.setAlignment(Qt.AlignCenter)
        self.ui.estop_color.setAlignment(Qt.AlignCenter)

        self.font = QFont()
        self.font.setPointSize(36)
        self.font.setWeight(600)

        self.ui.door_color.setFont(self.font)
        self.ui.door_color.setStyleSheet("color:#241f31;")

        self.ui.estop_color.setFont(self.font)
        self.ui.estop_color.setStyleSheet("color:#241f31;")
        
        # Use QTimer to update every 100ms
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.update_indicators)
        self.timer.start(100)

        #timer that polls /pick_status end point
        self.pick_status_Timer = QtCore.QTimer(self)
        self.pick_status_Timer.timeout.connect(self.poll_pick_status)
        self.pick_status_Timer.start(300)

        #timer that polls /response_status end point
        self.response_status_Timer = QtCore.QTimer(self)
        self.response_status_Timer.timeout.connect(self.response_status)
        self.response_status_Timer.start(300)

    def update_indicators(self):
        # Update door indicator: green for closed, yellow for open
        if self.ros_node.door_state == True:
            self.ui.door_color.setStyleSheet("background-color: green;")
            self.ui.door_color.setText("Closed")        
        else:
            self.ui.door_color.setStyleSheet("background-color: yellow;")
            self.ui.door_color.setText("Open")        
        
        # Update estop indicator: green for disengaged, red for engaged
        if self.ros_node.estop_state == False:
            self.ui.estop_color.setStyleSheet("background-color: green;")
            self.ui.estop_color.setText("Disengaged")
        else:
            self.ui.estop_color.setStyleSheet("background-color: red;")
            self.ui.estop_color.setText("Engaged")
        
        # Update stack light: 0 → green, 1 → yellow, -1 → red
        if self.ros_node.stack_light_state == 0:
            self.ui.stack_light_color.setStyleSheet("background-color: green;")
        elif self.ros_node.stack_light_state == 1:
            self.ui.stack_light_color.setStyleSheet("background-color: yellow;")
        elif self.ros_node.stack_light_state == -1:
            self.ui.stack_light_color.setStyleSheet("background-color: red;")
        else:
            self.ui.stack_light_color.setStyleSheet("background-color: gray;")

    def poll_pick_status(self):
        url = "http://localhost:8080//pick_request"  
        worker = GetStatusWorker(url)
        worker.signals.result.connect(self.handle_pick_status)
        worker.signals.error.connect(self.handle_pick_error)
        QtCore.QThreadPool.globalInstance().start(worker)

    def handle_pick_status(self, data):
        self.ui.pick_id_request.setText(str(data.get("pick_id", "N/A")))
        self.ui.quantity_request.setText(str(data.get("quantity", "N/A")))

    def handle_pick_error(self, error):
        print("HTTP Polling Error:", error)

    def response_status(self):
        url = "http://localhost:8081//response_status"  
        worker = GetStatusWorker(url)
        worker.signals.result.connect(self.handle_response_status)
        worker.signals.error.connect(self.handle_response_error)
        QtCore.QThreadPool.globalInstance().start(worker)

    def handle_response_status(self, data):
        self.ui.pick_id_response.setText(str(data.get("pickId", "N/A")))
        self.ui.pick_successful_response.setText(str(data.get("pickSuccessful", "N/A")))
        self.ui.error_message_response.setText(str(data.get("errorMessage", "N/A")))
        self.ui.item_barcode_response.setText(str(data.get("itemBarcode", "N/A")))

    def handle_response_error(self, error):
        print("HTTP Polling Error:", error)

def main():
    # Initialize ROS2
    rclpy.init()
    ros_node = RosSubscriberNode()
    
    # Create a MultiThreadedExecutor and add the node
    executor = MultiThreadedExecutor(num_threads=2)
    executor.add_node(ros_node)
    
    # Instead of threading.Thread, use QThreadPool with our QRunnable
    pool = QtCore.QThreadPool.globalInstance()
    ros_spin_task = RosSpinRunnable(ros_node, executor)
    pool.start(ros_spin_task)
    
    # Create and show the main window
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow(ros_node)
    window.show()
    
    try:
        ret = app.exec_()
    
    # Shutdown ROS and cleanup on exit

    except KeyboardInterrupt:
        sys.exit(ret)
        executor.shutdown()
        ros_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
